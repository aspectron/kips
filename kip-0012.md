# KIP-0012: Specification for Browser Extension Wallet APIs




<table>
  <tr><td>Layer</td><td>WASM32 Wallet SDK, Browser Extension Wallet APIs</td></tr>
  <tr><td>Title</td><td>Specification for Browser Extension Wallet APIs</td></tr>
  <tr><td>Authors</td><td>@aspect, @starkbamse, @KaffinPX, @mattoo</td></tr>
  <tr><td>Status</td><td>DRAFT / WIP</td></tr>
</table>


<br>

## **Goals**
- **Standardize Wallet APIs**: Define how wallets expose their functionalities to web apps.
- **Support Multiple Protocols**: Ensure compatibility with current and future Kaspa protocols.
- **Interoperability**: Allow seamless interaction between wallets and web apps through a uniform API structure.

<br>

## **Motivation**

The Kaspa ecosystem is witnessing the emergence of several Browser Extension Wallet standards for interfacing with web applications. This KIP aims to standardize the methodology by which wallets expose themselves to and communicate with these web applications.

Additionally, this KIP seeks to provide a common framework for wallets to showcase their capabilities, particularly in performing various functions (e.g., supporting PSKTs) and accommodating different emerging protocols. These protocols include, but are not limited to:

- **KRC-20 protocol** by Kasplex
- **KSC protocol** (future Sparkle Smart Contract assets)

This document is loosely based on Ethereum's [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963).

The specification is inspired by Ethereum's [EIP-6963](https://eips.ethereum.org/EIPS/eip-6963), providing a robust foundation for wallet and web app interaction.

<br>

## **Key Definitions**

- **Wallet**: A browser extension capable of storing Kaspa-based assets.
- **Web App**: A browser-accessible application interacting with the wallet to access stored funds and execute operations.


<br>

## **Specification**

**The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC-2119](https://datatracker.ietf.org/doc/html/rfc2119).**

<br>

###  Communication Events
   Wallets and web apps communicate through the browser’s `window` object using `CustomEvent` objects.

   - **`kaspa:requestProvider`**:  Request wallets to announce themselves.
   - **`kaspa:provider`**: Announces the wallet's presence to the web app.
   - **`kaspa:connect`**: Establishes connection between the wallet and the web app.
   - **`kaspa:invoke`**: Invokes specific wallet functionalities ( Used internally ).
   - **`kaspa:event`**: Used to send data from the wallet to the web app.
   - **`kaspa:disconnect`**: Terminates the connection between wallet and web app.

<br>


The wallet **MUST NOT** react to any requests except the **`kaspa:connect`** event. Only after an explicit connection request **MAY** the wallet react to subsequent requests made by the **Web App**.


|Sender||Event||Receiver|Interface|
|---|--|---|---|---|---|
| **Web App** | → | **Request Provider** (`kaspa:requestProvider`) | → | **Wallet** | `Notification`
| **Wallet** | → | **Provide Information** (`kaspa:provider`) | → | **Web App** |  `Notification`
| **Web App** | → | **Connect** (`kaspa:connect`) | → | **Wallet** | `Request`
| **Web App** | → | **Invoke Action** (`kaspa:invoke`) | → | **Wallet** | `Request`
| **Wallet** | → | **Send Response** (`kaspa:event`) | → | **Web App** |  `Response`
| **Web App / Wallet** | → | **Disconnect** (`kaspa:disconnect`) | → | **Wallet / Web App** | `Notification`


<br>


### Wallets

  Wallets **MUST** expose key methods (KaspaProvider):

  - **`request`**: Makes a specific request (e.g., transferring assets).
  - **`connect`**: Initiates a connection between the web app and the wallet.
  - **`disconnect`**: Ends the connection and prevents further communication.

<br>


Wallets  **SHOULD** support multiple protocols such as:
- **KRC-20**: Token standard for fungible tokens.
- **KSC**: Kaspa's future smart contract protocol for asset management.


<br>


### Icons/Images
The icon string **MUST** be a data URI as defined in [RFC-2397](https://datatracker.ietf.org/doc/html/rfc2397). The image **SHOULD** be a square with 96x96px minimum resolution. The image format is **RECOMMENDED** to be either lossless or vector-based such as PNG, WebP, or SVG to make the image easy to render on the Web App. Since SVG images can execute Javascript, applications and libraries **MUST** render SVG images using the <img> tag to ensure no untrusted Javascript execution can occur.

<br>

###
```typescript
// kaspa:provider 

interface Capability {
  protocol: string; // Protocol name, e.g. "KASPA", "KRC-20", "KSC"
  methods: string[]; // Array of method names in kebab-case : "get-account", "send", "sign-message
}

interface KaspaProviderInfo {
  id: string;
  name: string;
  icon: string;
  capabilities: Capability[] 
}

interface KaspaProvider {
  request: (args:Request) => Promise<Data>;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
}

interface KaspaProviderDetail {
  info: KaspaProviderInfo
  provider: KaspaProvider
}

interface Request {
  extensionId: string; // `browser.runtime.id`
  data: {
    protocol: string;
    method: string;
    params: Object;
  }, 
  error: string | Object | undefined;
}

interface Response {
  extensionId: string; // `browser.runtime.id`
  data: {
    protocol: string | undefined;
    data: any;
  }, 
  error: string | Object | undefined;
}

interface Notification {
  data: {
    protocol: string | undefined;
    data: any;
  }, 
  error: string | Object | undefined;
}
```
<br/>

### Reference


```typescript
async function request(protocol:string,method:string,params:Object): Promise<unknown> {
  const requestEvent = new CustomEvent("kaspa:invoke", {
    detail: Object.freeze({
      eventId: uuidv4(),
      extensionId: browser.runtime.id,
      data: {
        protocol,
        method,
        params
      },
      error: undefined,
    } as Request )
  });
  window.dispatchEvent(requestEvent);

  return new Promise((resolve, reject) => {
    const handleEvent = (event: CustomEvent<Response>) => {
      if (event.detail.eventId === requestEvent.detail.eventId) {
        window.removeEventListener("kaspa:event", handleEvent);
        if (event.detail.error) {
          reject(event.detail.error);
        } else {
          resolve(event.detail.data);
        }
      }
    };
    window.addEventListener("kaspa:event", handleEvent as EventListener);
  });
}


async function connect(): Promise<void> {
  const connectEvent = new CustomEvent("kaspa:connect", {
    detail: Object.freeze({
      eventId: uuidv4(),
      extensionId: browser.runtime.id,
      data:undefined,
      error:undefined
    } as Request ),
  });
  window.dispatchEvent(connectEvent);

  return new Promise((resolve, reject) => {
    const handleEvent = (event: CustomEvent<Response>) => {
      if (event.detail.eventId === connectEvent.detail.eventId) {
        window.removeEventListener("kaspa:event", handleEvent);
        if (event.detail.error) {
          reject(event.detail.error);
        } else {
          resolve();
        }
      }
    };
    window.addEventListener("kaspa:event", handleEvent as EventListener);
  });
}


async function disconnect() {
  
  let data:Data = {
    protocol:undefined,
    data:"User initiated"
  }

  const disconnectEvent = new CustomEvent("kaspa:disconnect", {
    detail: Object.freeze({
      extensionId: browser.runtime.id,
      data,
      error:undefined
    } as Notification ),
  });
  window.dispatchEvent(disconnectEvent);
}
```